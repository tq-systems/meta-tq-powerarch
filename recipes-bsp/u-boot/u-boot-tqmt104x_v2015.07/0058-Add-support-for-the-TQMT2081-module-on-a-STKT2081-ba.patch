From e8eedb7a3f6c8d4055be7844908c69c06406aff4 Mon Sep 17 00:00:00 2001
From: Stefan Lange <s.lange@gateware.de>
Date: Thu, 1 Mar 2018 13:03:51 +0100
Subject: [PATCH] Add support for the TQMT2081 module on a STKT2081 base board

Add initial board support for the TQMT2081 SOM board from TQ Systems which is
based on a Freescale T2081 PowerPC CPU.

The modules need a baseboard. Initially the STKT2081 starterkit mainboard is
supported.

Signed-off-by: Stefan Lange <s.lange@gateware.de>
---
 arch/powerpc/cpu/mpc85xx/Kconfig             |   5 +
 arch/powerpc/include/asm/config_mpc85xx.h    |   3 +-
 board/tqc/tqmt2081/Kconfig                   |  35 ++
 board/tqc/tqmt2081/Makefile                  |  20 +
 board/tqc/tqmt2081/README                    | 133 ++++++
 board/tqc/tqmt2081/ddr.c                     | 376 +++++++++++++++
 board/tqc/tqmt2081/ddr.h                     |  78 ++++
 board/tqc/tqmt2081/eth.c                     | 316 +++++++++++++
 board/tqc/tqmt2081/law.c                     |  34 ++
 board/tqc/tqmt2081/pci.c                     |  23 +
 board/tqc/tqmt2081/sleep.c                   |  95 ++++
 board/tqc/tqmt2081/sleep.h                   |  21 +
 board/tqc/tqmt2081/spl.c                     | 107 +++++
 board/tqc/tqmt2081/tlb.c                     | 152 ++++++
 board/tqc/tqmt2081/tqmt2081.c                | 108 +++++
 board/tqc/tqmt2081/tqmt2081.h                |  13 +
 board/tqc/tqmt2081/tqmt2081_pbi.cfg          |  41 ++
 board/tqc/tqmt2081/tqmt2081_serdes71_rcw.cfg |   9 +
 board/tqc/tqmt2081/tqmt2081_serdesf2_rcw.cfg |  19 +
 board/tqc/tqmt2081/vid.c                     | 136 ++++++
 board/tqc/tqmt2081/vid.h                     |  14 +
 include/configs/TQMT2081.h                   | 666 +++++++++++++++++++++++++++
 22 files changed, 2403 insertions(+), 1 deletion(-)
 create mode 100644 board/tqc/tqmt2081/Kconfig
 create mode 100644 board/tqc/tqmt2081/Makefile
 create mode 100644 board/tqc/tqmt2081/README
 create mode 100644 board/tqc/tqmt2081/ddr.c
 create mode 100644 board/tqc/tqmt2081/ddr.h
 create mode 100644 board/tqc/tqmt2081/eth.c
 create mode 100644 board/tqc/tqmt2081/law.c
 create mode 100644 board/tqc/tqmt2081/pci.c
 create mode 100644 board/tqc/tqmt2081/sleep.c
 create mode 100644 board/tqc/tqmt2081/sleep.h
 create mode 100644 board/tqc/tqmt2081/spl.c
 create mode 100644 board/tqc/tqmt2081/tlb.c
 create mode 100644 board/tqc/tqmt2081/tqmt2081.c
 create mode 100644 board/tqc/tqmt2081/tqmt2081.h
 create mode 100644 board/tqc/tqmt2081/tqmt2081_pbi.cfg
 create mode 100644 board/tqc/tqmt2081/tqmt2081_serdes71_rcw.cfg
 create mode 100644 board/tqc/tqmt2081/tqmt2081_serdesf2_rcw.cfg
 create mode 100644 board/tqc/tqmt2081/vid.c
 create mode 100644 board/tqc/tqmt2081/vid.h
 create mode 100644 include/configs/TQMT2081.h

diff --git a/arch/powerpc/cpu/mpc85xx/Kconfig b/arch/powerpc/cpu/mpc85xx/Kconfig
index a57f544..a6ccbd5 100644
--- a/arch/powerpc/cpu/mpc85xx/Kconfig
+++ b/arch/powerpc/cpu/mpc85xx/Kconfig
@@ -151,6 +151,10 @@ config TARGET_TQMT1042
         bool "Support TQMT1042"
         select SUPPORT_SPL
 
+config TARGET_TQMT2081
+        bool "Support TQMT2081"
+        select SUPPORT_SPL
+
 config TARGET_XPEDITE520X
 	bool "Support xpedite520x"
 
@@ -202,6 +206,7 @@ source "board/socrates/Kconfig"
 source "board/stx/stxgp3/Kconfig"
 source "board/stx/stxssa/Kconfig"
 source "board/tqc/tqmt104x/Kconfig"
+source "board/tqc/tqmt2081/Kconfig"
 source "board/xes/xpedite520x/Kconfig"
 source "board/xes/xpedite537x/Kconfig"
 source "board/xes/xpedite550x/Kconfig"
diff --git a/arch/powerpc/include/asm/config_mpc85xx.h b/arch/powerpc/include/asm/config_mpc85xx.h
index 895526b..d0e1e25 100644
--- a/arch/powerpc/include/asm/config_mpc85xx.h
+++ b/arch/powerpc/include/asm/config_mpc85xx.h
@@ -909,7 +909,8 @@ defined(CONFIG_PPC_T1014) || defined(CONFIG_PPC_T1013)
 #define CONFIG_SYS_FSL_ERRATUM_A006379
 #define ESDHCI_QUIRK_BROKEN_TIMEOUT_VALUE
 #define CONFIG_SYS_FSL_SFP_VER_3_0
-
+#define CONFIG_SYS_FSL_ERRATUM_A009942
+#define CONFIG_SYS_FSL_ERRATUM_A008109
 
 #elif defined(CONFIG_PPC_C29X)
 #define CONFIG_MAX_CPUS			1
diff --git a/board/tqc/tqmt2081/Kconfig b/board/tqc/tqmt2081/Kconfig
new file mode 100644
index 0000000..259c06583
--- /dev/null
+++ b/board/tqc/tqmt2081/Kconfig
@@ -0,0 +1,35 @@
+if TARGET_TQMT2081
+
+config SYS_BOARD
+	default "tqmt2081"
+
+config SYS_VENDOR
+	default "tqc"
+
+config SYS_CONFIG_NAME
+	default "TQMT2081"
+
+choice
+        prompt "TQMT2081 RCW configuration file"
+        default RCW_CFG_TQMT2081_SERDES71
+        help
+          select the RCW configuration file to be used for TQMT2081
+
+config RCW_CFG_TQMT2081_SERDES71
+        bool "TQMT2081 RCW configuration for SERDES mode = 71, default RCW configuration"
+        help
+          Select SERDES mode = 71 in reset configuration word.
+
+config RCW_CFG_TQMT2081_SERDESF2
+        bool "TQMT2081 RCW configuration for SERDES mode = F2"
+        help
+          Select SERDES mode = F2 in reset configuration word.
+
+endchoice
+
+config SYS_FSL_RCW
+        string
+        default "board/tqc/tqmt2081/tqmt2081_serdes71_rcw.cfg" if RCW_CFG_TQMT2081_SERDES71
+        default "board/tqc/tqmt2081/tqmt2081_serdesf2_rcw.cfg" if RCW_CFG_TQMT2081_SERDESF2
+
+endif
diff --git a/board/tqc/tqmt2081/Makefile b/board/tqc/tqmt2081/Makefile
new file mode 100644
index 0000000..7131353
--- /dev/null
+++ b/board/tqc/tqmt2081/Makefile
@@ -0,0 +1,20 @@
+#
+# Copyright 2017 TQ Systems GmbH
+#
+# Author: Stefan Lange <s.lange@gateware.de>
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+obj-y += spl.o
+else
+obj-$(CONFIG_TQMT2081) += tqmt2081.o
+obj-$(CONFIG_TQMT2081) += eth.o
+obj-$(CONFIG_TQMT2081) += vid.o
+obj-$(CONFIG_PCI)      += pci.o
+endif
+
+obj-y   += ddr.o
+obj-y   += law.o
+obj-y   += tlb.o
diff --git a/board/tqc/tqmt2081/README b/board/tqc/tqmt2081/README
new file mode 100644
index 0000000..0b4d856
--- /dev/null
+++ b/board/tqc/tqmt2081/README
@@ -0,0 +1,133 @@
+Overview
+--------
+The TQ embedded module TQMT2081 on STKT2081
+
+The baseboard STKT2081 supports the TQMT2081 and represents a universal platform
+for evaluation and development of customer specific platforms for this module.
+
+The baseboard STKT2081 supports multiple usage configurations of the T2081's
+SERDES lanes.
+
+For additional information, please see:
+http://support.tq-group.com/doku.php?id=en:power:tqmt2081:linux:overview
+
+T2080 SoC Overview (taken from board/freescale/t208xrdb/README)
+---------------------------------------------------------------
+The T2080 QorIQ multicore processor combines four dual-threaded e6500 Power
+Architecture processor cores with high-performance datapath acceleration
+logic and network and peripheral bus interfaces required for networking,
+telecom/datacom, wireless infrastructure, and mil/aerospace applications.
+
+T2080 includes the following functions and features:
+ - Four dual-threads 64-bit Power architecture e6500 cores, up to 1.8GHz
+ - 2MB L2 cache and 512KB CoreNet platform cache (CPC)
+ - Hierarchical interconnect fabric
+ - One 32-/64-bit DDR3/3L SDRAM memory controllers with ECC and interleaving
+ - Data Path Acceleration Architecture (DPAA) incorporating acceleration
+ - 16 SerDes lanes up to 10.3125 GHz
+ - 8 Ethernet interfaces, supporting combinations of the following:
+   - Up to four 10 Gbps Ethernet MACs
+   - Up to eight 1 Gbps Ethernet MACs
+   - Up to four 2.5 Gbps Ethernet MACs
+ - High-speed peripheral interfaces
+   - Four PCI Express controllers (two PCIe 2.0 and two PCIe 3.0 with SR-IOV)
+   - Two Serial RapidIO 2.0 controllers/ports running at up to 5 GHz
+ - Additional peripheral interfaces
+   - Two serial ATA (SATA 2.0) controllers
+   - Two high-speed USB 2.0 controllers with integrated PHY
+   - Enhanced secure digital host controller (SD/SDHC/SDXC/eMMC)
+   - Enhanced serial peripheral interface (eSPI)
+   - Four I2C controllers
+   - Four 2-pin UARTs or two 4-pin UARTs
+   - Integrated Flash Controller supporting NAND and NOR flash
+ - Three eight-channel DMA engines
+ - Support for hardware virtualization and partitioning enforcement
+ - QorIQ Platform's Trust Architecture 2.0
+
+Differences between T2080 and T2081
+-----------------------------------
+  Feature               T2080    T2081
+  1G Ethernet numbers:  8        6
+  10G Ethernet numbers: 4        2
+  SerDes lanes:         16       8
+  Serial RapidIO,RMan:  2        no
+  SATA Controller:      2        no
+  Aurora:               yes      no
+  SoC Package:          896-pins 780-pins
+
+(!) Note
+The TQMT2081 only features the T2081. No T2080 variant is available.
+
+
+STKT104x baseboard overview
+-------------------------
+ - SERDES Connections, 8 lanes information:
+	1: XFI
+	2: SGMII
+	3: SGMII
+	4: SGMII
+	5: Aurora / mini PCIe
+	6: connector PCIe1 x1 slot
+	7: mini PCIe connector / SGMII
+	8: SATA connector
+ - Ethernet
+     - Two on-board RGMII 10/100/1G ethernet ports
+     - additional ethernet: see SERDES
+ - Clocks
+     - System and DDR clock (SYSCLK, “DDRCLK”)
+     - SERDES clocks
+ - Power Supplies
+ - USB
+     - TQMT104x Supports two USB 2.0 ports with integrated PHYs
+     - TQMT104x USB1 connected to USB Hub
+	- USB_H1: type A port
+	- USB_H2: type A port
+	- USB_H3: miniPCIe slot
+	- USB_H4: LVDS connector
+     - TQMT104x USB2: type micro-A port
+ - SDHC
+     - SDHC/SDXC connector
+ - SPI
+    - (to pin header)
+ - Other IO
+    - Two Serial ports
+    - Four I2C ports
+
+
+Memory map
+----------
+Start Address  End Address      Description                     Size
+0xF_FE00_0000  0xF_FEFF_FFFF    CCSRBAR                         16MB
+0xF_F803_0000  0xF_F803_FFFF    PCI Express 4 I/O Space         64KB
+0xF_F802_0000  0xF_F802_FFFF    PCI Express 3 I/O Space	        64KB
+0xF_F801_0000  0xF_F801_FFFF    PCI Express 2 I/O Space         64KB
+0xF_F800_0000  0xF_F800_FFFF    PCI Express 1 I/O Space	        64KB
+0xF_F600_0000  0xF_F7FF_FFFF    Queue manager software portal   32MB
+0xF_F400_0000  0xF_F5FF_FFFF    Buffer manager software portal  32MB
+0xF_E800_0000  0xF_EFFF_FFFF    IFC - NOR Flash                 128MB
+0xF_0000_0000  0xF_003F_FFFF    DCSR                            4MB
+0xC_3000_0000  0xC_3FFF_FFFF    PCI Express 4 Mem Space         256MB
+0xC_2000_0000  0xC_2FFF_FFFF    PCI Express 3 Mem Space         256MB
+0xC_1000_0000  0xC_1FFF_FFFF    PCI Express 2 Mem Space         256MB
+0xC_0000_0000  0xC_0FFF_FFFF    PCI Express 1 Mem Space         256MB
+0x0_0000_0000  0x0_ffff_ffff    DDR                             2GB
+
+
+NOR Flash memory Map
+--------------------
+item		start address	content size	partition size
+RCW		0xe8000000	0x50		0x0020000
+Kernel		0xe8020000	0x54b000	0x0800000
+Device Tree	0xe8820000	0x7800		0x0020000
+Rootfs/Ramdisk 	0xe8840000	0x1900000	0x4000000
+Spare		0xec840000	-		0x3600000
+FMAN		0xeff00000	0x7ea0		0x0020000
+U-Boot Env	0xeff20000	-		0x0020000
+
+
+SD Card memory Map
+------------------
+Block		#blocks		Definition			Size
+0x008		2048		u-boot                          1MB
+0x800		0024		u-boot env (opt.)               8KB
+0x820		0256		FMAN Ucode                      128KB
diff --git a/board/tqc/tqmt2081/ddr.c b/board/tqc/tqmt2081/ddr.c
new file mode 100644
index 0000000..c89d514
--- /dev/null
+++ b/board/tqc/tqmt2081/ddr.c
@@ -0,0 +1,376 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * Based on board/freescale/t104xrdb/ddr.c
+ *
+ * Copyright 2017 TQ Systems GmbH
+ *
+ * Author: Stefan Lange <s.lange@gateware.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <i2c.h>
+#include <hwconfig.h>
+#include <asm/mmu.h>
+#include <fsl_ddr_sdram.h>
+#ifdef CONFIG_SYS_DDR_RAW_TIMING
+#include <fsl_ddr_dimm_params.h>
+#endif
+#include <asm/fsl_law.h>
+#include <asm/mpc85xx_gpio.h>
+#include "ddr.h"
+#include "sleep.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_SYS_DDR_RAW_TIMING
+#if defined(CONFIG_TQMT2081)
+/*
+ * Micron MT41K256M16TW-107 IT:P
+ */
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 1,
+	.rank_density = 2147483648u,
+	.capacity = 2147483648u,
+	.primary_sdram_width = 64,
+	.ec_sdram_width = 8,
+	.registered_dimm = 0,
+	.mirrored_dimm = 0,
+	.n_row_addr = 15,
+	.n_col_addr = 10,
+	.n_banks_per_sdram_device = 8,
+	.edc_config = EDC_ECC,
+	.burst_lengths_bitmask = 0x0c,
+
+	.tckmin_x_ps = 1070,    /* CL = 13 ; CWL = 8 tCK (AVG) (JEDEC:same)*/
+	.caslat_x = 0x2fe << 4, /* 5,6,7,8,9,10,11,12,13 */
+	.taa_ps = 13910,        /* Internal READ command to first data tAA
+				 * (JEDEC:same) */
+	.twr_ps = 15000,        /* Write recovery time tWR (JEDEC:same) */
+	.trcd_ps = 13910,	/* ACTIVATE to internal READ or WRITE delay
+				 * time tRCD (JEDEC:same) */
+	.trrd_ps = 5000,        /* ACTIVATE-to-ACTIVATE minimum command
+				 * period x16 (2KB page size) MIN = greater
+				 * of 4CK (5ns) or 7.5ns (JEDEC:same) */
+	.trp_ps = 13910,        /* PRECHARGE command period tRP (JEDEC:same) */
+	.tras_ps = 34000,       /* ACTIVATE-to-PRECHARGE command period tRAS
+				 * (JEDEC:same, max<9*tREFI) */
+	.trc_ps = 47910,        /* ACTIVATE-to-ACTIVATE command period tRC
+				 * (JEDEC:same) */
+	.trfc_ps = 260000,	/* REFRESH-to-ACTIVATE or REFRESH command period
+				 * tRFC -> 4Gb (JEDEC:same) */
+	.twtr_ps = 7500,	/* Delay from start of internal WRITE
+				 * transaction to internal READ command tWTR:
+				 * MIN = greater of 4CK (5ns) or 7.5ns
+				 * (JEDEC:same) */
+	.trtp_ps = 7500,	/* READ-to-PRECHARGE time tRTP:
+				 * MIN = greater of 4CK (5ns) or 7.5ns
+				 * (JEDEC:same) */
+	.refresh_rate_ps = 3900000,	/* Max average periodic refresh  tREFI
+					 * (JEDEC:same) */
+	.tfaw_ps = 35000,       /* 2kB page size/x16 -> min 40ns (JEDEC:40ns) */
+};
+#else
+#error Missing raw timing data for this board
+#endif
+
+int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
+			    unsigned int controller_number,
+			    unsigned int dimm_number)
+{
+	const char dimm_model[] = "Fixed DDR on board";
+
+	if ((controller_number == 0) && (dimm_number == 0)) {
+		memcpy(pdimm, &ddr_raw_timing, sizeof(dimm_params_t));
+		memset(pdimm->mpart, 0, sizeof(pdimm->mpart));
+		memcpy(pdimm->mpart, dimm_model, sizeof(dimm_model) - 1);
+	}
+
+	return 0;
+}
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+			   dimm_params_t *pdimm,
+			   unsigned int ctrl_num)
+{
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+
+	if (ctrl_num > 1) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+	if (!pdimm->n_ranks)
+		return;
+
+	/*
+	 * we use identical timing for all slots. If needed, change the code
+	 * to pbsp = udimms[ctrl_num];
+	 */
+	pbsp = udimms[0];
+
+	/* Get clk_adjust, wrlvl_start, wrlvl_ctl, according to the board ddr
+	 * freqency and n_banks specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(0) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm->n_ranks &&
+		    (pdimm->rank_density >> 30) >= pbsp->rank_gb) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found");
+		printf("for data rate %lu MT/s\n", ddr_freq);
+		printf("Trying to use the highest speed (%u) parameters\n",
+		       pbsp_highest->datarate_mhz_high);
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n"
+		"\tclk_adjust %d, wrlvl_start %d, wrlvl_ctrl_2 0x%x, "
+		"wrlvl_ctrl_3 0x%x\n",
+		pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb,
+		pbsp->clk_adjust, pbsp->wrlvl_start, pbsp->wrlvl_ctl_2,
+		pbsp->wrlvl_ctl_3);
+
+	/*
+	 * Factors to consider for half-strength driver enable:
+	 *      - number of DIMMs installed
+	 */
+	popts->half_strength_driver_enable = 0;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+
+	/*
+	 * Rtt and Rtt_WR override
+	 */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+	/* DHC_EN =1, ODT = 75 Ohm */
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_75ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_75ohm);
+}
+
+/* use fixed timing if CONFIG_SYS_DDR_RAW_TIMING is not defined */
+#else /* CONFIG_SYS_DDR_RAW_TIMING */
+/*
+ * Fixed sdram init -- doesn't use serial presence detect.
+ */
+phys_size_t fixed_sdram(void)
+{
+	struct ccsr_ddr *ddr = (struct ccsr_ddr *)CONFIG_SYS_FSL_DDR_ADDR;
+	u32 temp_sdram_cfg;
+	u32 total_gb_size_per_controller;
+	unsigned int bus_width;
+	int timeout;
+	size_t ddr_size;
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A009942
+	u32 tmp;
+	u32 CPOmin, CPOmax;
+#endif
+
+	out_be32(&ddr->sdram_cfg, DDR_SDRAM_CFG);
+
+	out_be32(&ddr->cs0_bnds, DDR_CS0_BNDS);
+	out_be32(&ddr->cs0_config, DDR_CS0_CONFIG);
+	out_be32(&ddr->cs0_config_2, DDR_CS0_CONFIG2);
+
+	out_be32(&ddr->timing_cfg_3, DDR_TIMING_CFG_3);
+	out_be32(&ddr->timing_cfg_0, DDR_TIMING_CFG_0);
+	out_be32(&ddr->timing_cfg_1, DDR_TIMING_CFG_1);
+	out_be32(&ddr->timing_cfg_2, DDR_TIMING_CFG_2);
+
+	out_be32(&ddr->sdram_mode, DDR_SDRAM_MODE);
+	out_be32(&ddr->sdram_mode_2, DDR_SDRAM_MODE_2);
+
+	out_be32(&ddr->sdram_md_cntl, DDR_SDRAM_MD_CNTL);
+	out_be32(&ddr->sdram_interval, DDR_SDRAM_INTERVAL);
+	out_be32(&ddr->sdram_data_init, DDR_DATA_INIT);
+	out_be32(&ddr->sdram_clk_cntl, DDR_SDRAM_CLK_CNTL);
+
+	out_be32(&ddr->timing_cfg_4, DDR_TIMING_CFG_4);
+	out_be32(&ddr->timing_cfg_5, DDR_TIMING_CFG_5);
+
+	out_be32(&ddr->ddr_zq_cntl, DDR_DDR_ZQ_CNTL);
+
+	out_be32(&ddr->ddr_wrlvl_cntl, DDR_DDR_WRLVL_CNTL);
+
+	out_be32(&ddr->ddr_wrlvl_cntl_2, DDR_DDR_WRLVL_CNTL_2);
+	out_be32(&ddr->ddr_wrlvl_cntl_3, DDR_DDR_WRLVL_CNTL_3);
+
+	out_be32(&ddr->ddr_sr_cntr, DDR_SR_CNTR);
+	out_be32(&ddr->ddr_sdram_rcw_1, DDR_SDRAM_RCW_1);
+	out_be32(&ddr->ddr_sdram_rcw_2, DDR_SDRAM_RCW_2);
+	out_be32(&ddr->ddr_cdr1, DDR_DDR_CDR1);
+	out_be32(&ddr->sdram_cfg_2,  DDR_SDRAM_CFG_2);
+	out_be32(&ddr->ddr_cdr2, DDR_DDR_CDR2);
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A008109
+	/* set DDR_SDRAM_CFG_2[DDR_SLOW] */
+	tmp = in_be32(&ddr->sdram_cfg_2);
+	tmp |= 0x00008000;
+	out_be32(&ddr->sdram_cfg_2, tmp);
+
+	/* read DEBUG_19 register and OR with 0x00000002 */
+	tmp = in_be32(&ddr->debug[18]);
+	tmp |= 0x00000002;
+	out_be32(&ddr->debug[18], tmp);
+
+	/* write DEBUG_29 = 0x30000000 */
+	out_be32(&ddr->debug[28], 0x30000000);
+#endif /* CONFIG_SYS_FSL_ERRATUM_A008109 */
+
+#ifdef CONFIG_SYS_FSL_ERRATUM_A009942
+	tmp = in_be32(&ddr->debug[28]);
+	tmp &= 0xFF0FFF00;
+	tmp |= 0x00700076;
+	out_be32(&ddr->debug[28], tmp);
+
+	CPOmin = 0; CPOmax = 0;
+	tmp = in_be32(&ddr->debug[9]);   /* CPO Lane 0/1 */
+	CPOmin = min((u32)CPOmin, (u32)(tmp & 0xFFFF0000L) >> 16);
+	CPOmin = min((u32)CPOmin, (u32)(tmp & 0x0000FFFFL));
+	CPOmax = max((u32)CPOmax, (u32)(tmp & 0xFFFF0000L) >> 16);
+	CPOmax = max((u32)CPOmax, (u32)(tmp & 0x0000FFFFL));
+	tmp = in_be32(&ddr->debug[10]);  /* CPO Lane 2/3 */
+	CPOmin = min((u32)CPOmin, (u32)(tmp & 0xFFFF0000L) >> 16);
+	CPOmin = min((u32)CPOmin, (u32)(tmp & 0x0000FFFFL));
+	CPOmax = max((u32)CPOmax, (u32)(tmp & 0xFFFF0000L) >> 16);
+	CPOmax = max((u32)CPOmax, (u32)(tmp & 0x0000FFFFL));
+	tmp = in_be32(&ddr->debug[11]);  /* CPO Lane 4/5 */
+	CPOmin = min((u32)CPOmin, (u32)(tmp & 0xFFFF0000L) >> 16);
+	CPOmin = min((u32)CPOmin, (u32)(tmp & 0x0000FFFFL));
+	CPOmax = max((u32)CPOmax, (u32)(tmp & 0xFFFF0000L) >> 16);
+	CPOmax = max((u32)CPOmax, (u32)(tmp & 0x0000FFFFL));
+	tmp = in_be32(&ddr->debug[12]);  /* CPO Lane 6/7 */
+	CPOmin = min((u32)CPOmin, (u32)(tmp & 0xFFFF0000L) >> 16);
+	CPOmin = min((u32)CPOmin, (u32)(tmp & 0x0000FFFFL));
+	CPOmax = max((u32)CPOmax, (u32)(tmp & 0xFFFF0000L) >> 16);
+	CPOmax = max((u32)CPOmax, (u32)(tmp & 0x0000FFFFL));
+#ifdef CONFIG_DDR_ECC
+	tmp = in_be32(&ddr->debug[13]);  /* CPO ECC Lane */
+	CPOmin = min((u32)CPOmin, (u32)(tmp & 0xFFFF0000L) >> 16);
+	CPOmin = min((u32)CPOmin, (u32)(tmp & 0x0000FFFFL));
+	CPOmax = max((u32)CPOmax, (u32)(tmp & 0xFFFF0000L) >> 16);
+	CPOmax = max((u32)CPOmax, (u32)(tmp & 0x0000FFFFL));
+#endif /* CONFIG_DDR_ECC */
+	tmp = in_be32(&ddr->debug[28]);
+	tmp &= 0xFF000000L;
+	tmp >>= 24;
+
+	if ((CPOmin + 0x3FL) < tmp) {
+		tmp = in_be32(&ddr->debug[28]);
+		tmp &= 0x00FFFFFFL;
+		tmp |= ((u32)(((CPOmax + CPOmin) >> 1) + 0x27) << 24);
+		out_be32(&ddr->debug[28], tmp);
+	}
+#endif /* CONFIG_SYS_FSL_ERRATUM_A009942 */
+
+	udelay(500);
+	asm volatile("sync;isync");
+
+	temp_sdram_cfg = (in_be32(&ddr->sdram_cfg) & ~SDRAM_CFG_BI);
+	out_be32(&ddr->sdram_cfg, temp_sdram_cfg | DDR_SDRAM_CFG_MEM_EN);
+	asm volatile("sync;isync");
+
+	/* Size; no Interleaving! */
+	total_gb_size_per_controller = 1 << (
+		((DDR_CS0_CONFIG >> 14) & 0x3) + 2 +    /* BA_BITS_CSn  */
+		((DDR_CS0_CONFIG >> 8) & 0x7) + 12 +    /* ROW_BITS_CSn */
+		((DDR_CS0_CONFIG >> 0) & 0x7) + 8 +     /* COL_BITS_CSn */
+		3 - ((DDR_SDRAM_CFG >> 19) & 0x3) -     /* 0 = 64bit, 1 = 32bit bus */
+		26);                    /* minus 26 (count of 64M) */
+
+	/*
+	 * total memory / bus width = transactions needed
+	 * transactions needed / data rate = seconds
+	 * to add plenty of buffer, double the time
+	 * For example, 2GB on 666MT/s 64-bit bus takes about 402ms
+	 * Let's wait for 800ms
+	 */
+	bus_width = 3 - ((ddr->sdram_cfg & SDRAM_CFG_DBW_MASK) >>
+			SDRAM_CFG_DBW_SHIFT);
+	timeout = ((total_gb_size_per_controller << (6 - bus_width)) * 100 /
+			(get_ddr_freq(0) >> 20)) << 1;
+
+	/* Poll DDR_SDRAM_CFG_2[D_INIT] bit until auto-data init is done.  */
+	while ((in_be32(&ddr->sdram_cfg_2) & SDRAM_CFG2_D_INIT) &&
+	       (timeout >= 0)) {
+		udelay(10000);          /* throttle polling rate */
+		timeout--;
+	}
+
+	if (timeout <= 0)
+		printf("Waiting for D_INIT timeout. Memory may not work.\n");
+
+	ddr_size = (phys_size_t)CONFIG_SYS_SDRAM_SIZE * 1024 * 1024;
+
+	if (set_ddr_laws(CONFIG_SYS_DDR_SDRAM_BASE, ddr_size,
+			 LAW_TRGT_IF_DDR_1) < 0) {
+		printf("ERROR setting Local Access Windows for DDR\n");
+		return 0;
+	}
+
+	return ddr_size;
+}
+#endif /* CONFIG_SYS_DDR_RAW_TIMING */
+
+#if defined(CONFIG_DEEP_SLEEP)
+void board_mem_sleep_setup(void)
+{
+	/* Disable MCKE isolation through system controller */
+	gpio_set_value(29, 0);
+	udelay(1);
+}
+#endif
+
+phys_size_t initdram(int board_type)
+{
+	phys_size_t dram_size;
+
+#if defined(CONFIG_SPL_BUILD) || !defined(CONFIG_RAMBOOT_PBL)
+#ifdef CONFIG_SYS_DDR_RAW_TIMING
+	puts("Initializing....using raw ddr timings\n");
+	dram_size = fsl_ddr_sdram();
+#else
+	puts("Initializing....using fixed ddr timings\n");
+	dram_size = fixed_sdram();
+#endif /* CONFIG_SYS_DDR_RAW_TIMING */
+
+	dram_size = setup_ddr_tlbs(dram_size / 0x100000);
+	dram_size *= 0x100000;
+
+#else
+	dram_size = (phys_size_t)CONFIG_SYS_SDRAM_SIZE * 1024 * 1024;
+#endif /* CONFIG_SPL_BUILD || !CONFIG_RAMBOOT_PBL */
+
+#if defined(CONFIG_DEEP_SLEEP) && !defined(CONFIG_SPL_BUILD)
+	fsl_dp_resume();
+#endif
+
+	return dram_size;
+}
diff --git a/board/tqc/tqmt2081/ddr.h b/board/tqc/tqmt2081/ddr.h
new file mode 100644
index 0000000..e1416af
--- /dev/null
+++ b/board/tqc/tqmt2081/ddr.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2017 TQ Systems GmbH
+ *
+ * Author: Stefan Lange <s.lange@gateware.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __DDR_H__
+#define __DDR_H__
+
+#ifdef CONFIG_SYS_DDR_RAW_TIMING
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 rank_gb;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+};
+
+/*
+ * These tables contain all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ */
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|    hi| rank|  clk| wrlvl |     wrlvl | wrlv
+	 * ranks|   mhz| GB  |adjst| start |      ctl2 | ctl3
+	 */
+	{      1,  1866,    0,    4,      7, 0x00000000, 0x00000000},
+	{}
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+};
+
+#else /* CONFIG_SYS_DDR_RAW_TIMING */
+
+/* extracted from FSL_DDR raw timing */
+/* 0x67040008 instead of 0xe7040008 to make sure MEM_EN is not set too early*/
+#define DDR_SDRAM_CFG                   0x67040008
+#define DDR_CS0_BNDS                    0x0000007F
+#define DDR_CS0_CONFIG                  0x80044302
+#define DDR_CS0_CONFIG2                 0x00000000
+#define DDR_TIMING_CFG_0                0x9011010e
+#define DDR_TIMING_CFG_1                0xd0d8be57
+#define DDR_TIMING_CFG_2                0x0048e161
+#define DDR_TIMING_CFG_3                0x020e1000
+#define DDR_TIMING_CFG_4                0x00000001
+#define DDR_TIMING_CFG_5                0x05401400
+#define DDR_SDRAM_CFG_2                 0x24401310
+#define DDR_SDRAM_MODE                  0x00461e14
+#define DDR_SDRAM_MODE_2                0x00200000
+#define DDR_SDRAM_INTERVAL              0x0e380100
+#define DDR_DDR_WRLVL_CNTL              0x86752607
+#define DDR_DDR_WRLVL_CNTL_2            0x00000000
+#define DDR_DDR_WRLVL_CNTL_3            0x00000000
+#define DDR_DDR_CDR1                    0x80040000
+#define DDR_DDR_CDR2                    0x00000001
+#define DDR_SDRAM_CLK_CNTL              0x02000000
+#define DDR_DDR_ZQ_CNTL                 0x89080600
+#define DDR_DATA_INIT                   0xDEADBEEF
+#define DDR_SDRAM_MD_CNTL               0x00000000
+#define DDR_SR_CNTR                     0x00000000
+#define DDR_SDRAM_RCW_1                 0x00000000
+#define DDR_SDRAM_RCW_2                 0x00000000
+#define DDR_INIT_ADDR                   0x00000000
+#define DDR_INIT_EXT_ADDR               0x00000000
+#define DDR_SDRAM_CFG_MEM_EN            0x80000000
+
+#endif /* CONFIG_SYS_DDR_RAW_TIMING */
+
+#endif /* __DDR_H__ */
diff --git a/board/tqc/tqmt2081/eth.c b/board/tqc/tqmt2081/eth.c
new file mode 100644
index 0000000..af992d1
--- /dev/null
+++ b/board/tqc/tqmt2081/eth.c
@@ -0,0 +1,316 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * Based on board/freescale/t104xrdb/eth.c
+ *
+ * Copyright 2017 TQ Systems GmbH
+ *
+ * Author: Stefan Lange <s.lange@gateware.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/fsl_serdes.h>
+#include <asm/immap_85xx.h>
+#include <fm_eth.h>
+#include <fsl_mdio.h>
+#include <malloc.h>
+#include <asm/fsl_dtsec.h>
+#include <phy.h>
+#include <vsc9953.h>
+#include <i2c.h>
+#include <hwconfig.h>
+
+#define CONFIG_SYS_MODULE_EEPROM		0x50
+#define CONFIG_SYS_MODULE_EEPROM_ADLEN          0x1
+#define CONFIG_SYS_MODULE_EEPROM_MAC_AD_OFFSET  0x20
+
+#define MII_DP83867_REGCR             0x000D
+#define MII_DP83867_ADDAR             0x000E
+#define MII_DP83867_REGCR_AD          0x001F
+#define MII_DP83867_REGCR_DAT         0x401F
+#define MII_DP83867_RGMIICTL          0x0032
+#define MII_DP83867_RGMIIDCTL         0x0086
+#define MII_DP83867_BYTEORDER         0x00DC
+#define MII_88E1340_PAGEAD            0x0016
+#define MII_DP83867_IOMUXCFG          0x0170
+
+static int eth_phy_qsgmii_reprogram;
+
+static int _tq_get_macaddress_from_eeprom(void)
+{
+	int err;
+	int i, j;
+	uint8_t ethAddrBuf[6];
+	char ethAddrStr[18]; /* xx:xx:xx:xx:xx:xx\0 */
+	const char *varname;
+	unsigned int old_i2c_bus;
+
+	/* Read MAC address from EEPROM */
+	old_i2c_bus = i2c_get_bus_num();
+	i2c_set_bus_num(0);
+	err = i2c_read(CONFIG_SYS_MODULE_EEPROM,
+		       CONFIG_SYS_MODULE_EEPROM_MAC_AD_OFFSET,
+		       CONFIG_SYS_MODULE_EEPROM_ADLEN, ethAddrBuf,
+		       sizeof(ethAddrBuf));
+	i2c_set_bus_num(old_i2c_bus);
+
+	if (err) {
+		printf("Could not read MAC addresses: %d\n", err);
+		return err;
+	} else {
+		for (i = 0; i < (CONFIG_SYS_NUM_FM1_DTSEC +
+		    CONFIG_SYS_NUM_FM1_10GEC); i++) {
+			if (i == 0)
+				varname = "ethaddr";
+			else if (i == 1)
+				varname = "eth1addr";
+			else if (i == 2)
+				varname = "eth2addr";
+			else if (i == 3)
+				varname = "eth3addr";
+			else if (i == 4)
+				varname = "eth4addr";
+			else if (i == 5)
+				varname = "eth5addr";
+			else if (i == 6)
+				varname = "eth6addr";
+			else if (i == 7)
+				varname = "eth7addr";
+			else if (i == 8)
+				varname = "eth8addr";
+			else if (i == 9)
+				varname = "eth9addr";
+			else if (i == 10)
+				varname = "eth10addr";
+			sprintf(
+				ethAddrStr, "%02x:%02x:%02x:%02x:%02x:%02x",
+				ethAddrBuf[0], ethAddrBuf[1], ethAddrBuf[2],
+				ethAddrBuf[3], ethAddrBuf[4], ethAddrBuf[5]
+			);
+			setenv(varname, ethAddrStr);
+
+			/* Increment MAC address by 1 with overflow. */
+			j = sizeof(ethAddrBuf);
+			do {
+				j--;
+				ethAddrBuf[j]++;
+			} while (ethAddrBuf[j] == 0 && j > 0);
+		}
+	}
+	return 0;
+}
+
+/*
+ * Set RGMII delay and other values in ethernet phys
+ * located on the STKTxxxx starterkit
+ */
+int board_phy_config(struct phy_device *phydev)
+{
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	if (phydev->addr == CONFIG_SYS_RGMII1_PHY_ADDR) {
+		/* set EC1 RGMII delay (extended write) */
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_REGCR,
+			  MII_DP83867_REGCR_AD);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_ADDAR,
+			  MII_DP83867_RGMIIDCTL);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_REGCR,
+			  MII_DP83867_REGCR_DAT);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_ADDAR, 0x0097);
+
+		/* activate EC1 RGMII TX and RX delay (extended write) */
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_REGCR,
+			  MII_DP83867_REGCR_AD);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_ADDAR,
+			  MII_DP83867_RGMIICTL);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_REGCR,
+			  MII_DP83867_REGCR_DAT);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_ADDAR, 0x00D3);
+	}
+
+	if (phydev->addr == CONFIG_SYS_RGMII2_PHY_ADDR) {
+		/* set EC2 RGMII phy to output 125MHz on CLK_OUT pin
+		 * this is required for the MAC
+		 */
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_REGCR,
+			  MII_DP83867_REGCR_AD);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_ADDAR,
+			  MII_DP83867_IOMUXCFG);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_REGCR,
+			  MII_DP83867_REGCR_DAT);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_ADDAR, 0x000D);
+
+		/* set EC2 RGMII delay (extended write) */
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_REGCR,
+			  MII_DP83867_REGCR_AD);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_ADDAR,
+			  MII_DP83867_RGMIIDCTL);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_REGCR,
+			  MII_DP83867_REGCR_DAT);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_ADDAR, 0x0097);
+
+		/* activate EC2 RGMII TX and RX delay (extended write) */
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_REGCR,
+			  MII_DP83867_REGCR_AD);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_ADDAR,
+			  MII_DP83867_RGMIICTL);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_REGCR,
+			  MII_DP83867_REGCR_DAT);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_ADDAR, 0x00D3);
+	}
+
+	if (phydev->addr == CONFIG_SYS_SGMII1_PHY_ADDR) {
+		/* do 88E1340 phy initialisation #1 */
+		/* as described in MV-S301615 release note */
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_88E1340_PAGEAD, 0xFF);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x18, 0x2800);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x17, 0x2001);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_88E1340_PAGEAD, 0x00);
+		/* do 88E1340 phy initialisation #2 */
+		/* as described in MV-S301615 release note */
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_88E1340_PAGEAD, 0x00);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x0003);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x0002);
+		phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x0000);
+	}
+
+	if (phydev->addr == CONFIG_SYS_SGMII2_PHY_ADDR) {
+		/* set DP83867 byteordering hidden register (extended write) */
+		/* workaround for pre-production grade silicon */
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_REGCR,
+			  MII_DP83867_REGCR_AD);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_ADDAR,
+			  MII_DP83867_BYTEORDER);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_REGCR,
+			  MII_DP83867_REGCR_DAT);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_ADDAR, 0x3800);
+	}
+
+	if (phydev->addr == CONFIG_SYS_SGMII5_PHY_ADDR) {
+		/* set DP83867 byteordering hidden register (extended write) */
+		/* workaround for pre-production grade silicon */
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_REGCR,
+			  MII_DP83867_REGCR_AD);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_ADDAR,
+			  MII_DP83867_BYTEORDER);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_REGCR,
+			  MII_DP83867_REGCR_DAT);
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_DP83867_ADDAR, 0x3800);
+	}
+
+	return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+#ifdef CONFIG_FMAN_ENET
+	struct memac_mdio_info memac_mdio_info;
+	struct memac_mdio_info tgec_mdio_info;
+	unsigned int i;
+	int phy_addr = 0;
+	struct mii_dev *dev;
+
+	printf("Initializing Fman\n");
+
+	memac_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_DTSEC_MDIO_ADDR;
+	memac_mdio_info.name = DEFAULT_FM_MDIO_NAME;
+
+	/* Register the real 1G MDIO bus */
+	fm_memac_mdio_init(bis, &memac_mdio_info);
+
+	tgec_mdio_info.regs =
+		(struct memac_mdio_controller *)CONFIG_SYS_FM1_TGEC_MDIO_ADDR;
+	tgec_mdio_info.name = DEFAULT_FM_TGEC_MDIO_NAME;
+
+	/* Register the 10G MDIO bus */
+	fm_memac_mdio_init(bis, &tgec_mdio_info);
+
+	/*
+	 * Program on board RGMII, SGMII PHY addresses.
+	 */
+	for (i = FM1_DTSEC1; i < FM1_DTSEC1 + CONFIG_SYS_NUM_FM1_DTSEC; i++) {
+		int idx = i - FM1_DTSEC1;
+
+		switch (fm_info_get_enet_if(i)) {
+		case PHY_INTERFACE_MODE_SGMII:
+			printf("Eth:   configuring FM1_DTSEC%i as SGMII\n",
+			       i + 1);
+			if (i == FM1_DTSEC1)
+				phy_addr = CONFIG_SYS_SGMII1_PHY_ADDR;
+			if (i == FM1_DTSEC2)
+				phy_addr = CONFIG_SYS_SGMII2_PHY_ADDR;
+			if (i == FM1_DTSEC5)
+				phy_addr = CONFIG_SYS_SGMII5_PHY_ADDR;
+			/* SGMII DTSEC6 Serdes Lane H connected to SATA
+			 * on STKTxxxx, not used
+			 */
+			if (i == FM1_DTSEC6) {
+				printf("Eth:   SGMII DTSEC6 not used on STKT2081\n");
+				phy_addr = 0;
+			}
+			fm_info_set_phy_address(i, phy_addr);
+			break;
+		case PHY_INTERFACE_MODE_RGMII:
+			printf("Eth:   configuring FM1_DTSEC%i as RGMII\n",
+			       i + 1);
+			if (i == FM1_DTSEC3)
+				phy_addr = CONFIG_SYS_RGMII1_PHY_ADDR;
+			if (i == FM1_DTSEC4)
+				phy_addr = CONFIG_SYS_RGMII2_PHY_ADDR;
+			fm_info_set_phy_address(i, phy_addr);
+			break;
+		case PHY_INTERFACE_MODE_QSGMII:
+			printf("Eth:   configuring FM1_DTSEC%i as QSGMII\n",
+			       i + 1);
+			eth_phy_qsgmii_reprogram = 1;
+			fm_info_set_phy_address(i, phy_addr);
+			break;
+		case PHY_INTERFACE_MODE_NONE:
+			fm_info_set_phy_address(i, 0);
+			break;
+		default:
+			printf("Fman1: DTSEC%u set to unknown interface %i\n",
+			       idx + 1, fm_info_get_enet_if(i));
+			fm_info_set_phy_address(i, 0);
+			break;
+		}
+		if (fm_info_get_enet_if(i) == PHY_INTERFACE_MODE_QSGMII ||
+		    fm_info_get_enet_if(i) == PHY_INTERFACE_MODE_NONE)
+			fm_info_set_mdio(i, NULL);
+		else
+			fm_info_set_mdio(i,
+					 miiphy_get_dev_by_name(
+							DEFAULT_FM_MDIO_NAME));
+	}
+
+	for (i = FM1_10GEC1; i < FM1_10GEC1 + CONFIG_SYS_NUM_FM1_10GEC; i++) {
+		switch (fm_info_get_enet_if(i)) {
+		case PHY_INTERFACE_MODE_XGMII:
+			printf("Eth:   configuring FM1_10GEC%i as XGMII\n",
+			       i + 1);
+			dev = miiphy_get_dev_by_name(DEFAULT_FM_TGEC_MDIO_NAME);
+			fm_info_set_mdio(i, dev);
+			break;
+		default:
+			break;
+		}
+	}
+
+	/* get MAC addresses from I2C EEPROM */
+	_tq_get_macaddress_from_eeprom();
+
+	cpu_eth_init(bis);
+#endif
+
+	return pci_eth_init(bis);
+}
+
+void fdt_fixup_board_enet(void *fdt)
+{
+	return;
+}
diff --git a/board/tqc/tqmt2081/law.c b/board/tqc/tqmt2081/law.c
new file mode 100644
index 0000000..eb82431
--- /dev/null
+++ b/board/tqc/tqmt2081/law.c
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2008-2014 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+struct law_entry law_table[] = {
+	SET_LAW(CONFIG_SYS_FLASH_BASE_PHYS, LAW_SIZE_256M, LAW_TRGT_IF_IFC),
+#ifdef CONFIG_SYS_BMAN_MEM_PHYS
+	SET_LAW(CONFIG_SYS_BMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_BMAN),
+#endif
+#ifdef CONFIG_SYS_QMAN_MEM_PHYS
+	SET_LAW(CONFIG_SYS_QMAN_MEM_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_QMAN),
+#endif
+#ifdef CONFIG_SYS_CPLD_BASE_PHYS
+	SET_LAW(CONFIG_SYS_CPLD_BASE_PHYS, LAW_SIZE_4K, LAW_TRGT_IF_IFC),
+#endif
+#ifdef CONFIG_SYS_DCSRBAR_PHYS
+	/* Limit DCSR to 32M to access NPC Trace Buffer */
+	SET_LAW(CONFIG_SYS_DCSRBAR_PHYS, LAW_SIZE_32M, LAW_TRGT_IF_DCSR),
+#endif
+#ifdef CONFIG_SYS_NAND_BASE_PHYS
+	SET_LAW(CONFIG_SYS_NAND_BASE_PHYS, LAW_SIZE_1M, LAW_TRGT_IF_IFC),
+#endif
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
diff --git a/board/tqc/tqmt2081/pci.c b/board/tqc/tqmt2081/pci.c
new file mode 100644
index 0000000..ba7041a
--- /dev/null
+++ b/board/tqc/tqmt2081/pci.c
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2007-2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <pci.h>
+#include <asm/fsl_pci.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <asm/fsl_serdes.h>
+
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+
+void pci_of_setup(void *blob, bd_t *bd)
+{
+	FT_FSL_PCI_SETUP;
+}
diff --git a/board/tqc/tqmt2081/sleep.c b/board/tqc/tqmt2081/sleep.c
new file mode 100644
index 0000000..2af338e
--- /dev/null
+++ b/board/tqc/tqmt2081/sleep.c
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/immap_85xx.h>
+#include "sleep.h"
+#ifdef CONFIG_U_QE
+#include "../../../drivers/qe/qe.h"
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void __weak board_mem_sleep_setup(void)
+{
+}
+
+void __weak board_sleep_prepare(void)
+{
+}
+
+bool is_warm_boot(void)
+{
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+	if (in_be32(&gur->scrtsr[0]) & DCFG_CCSR_CRSTSR_WDRFR)
+		return 1;
+
+	return 0;
+}
+
+void fsl_dp_disable_console(void)
+{
+	gd->flags |= GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE;
+}
+
+/*
+ * When wakeup from deep sleep, the first 128 bytes space
+ * will be used to do DDR training which corrupts the data
+ * in there. This function will restore them.
+ */
+static void dp_ddr_restore(void)
+{
+	u64 *src, *dst;
+	int i;
+	struct ccsr_scfg __iomem *scfg = (void *)CONFIG_SYS_MPC85xx_SCFG;
+
+	/* get the address of ddr date from SPARECR3 */
+	src = (u64 *)(in_be32(&scfg->sparecr[2]) + DDR_BUFF_LEN - 8);
+	dst = (u64 *)(CONFIG_SYS_SDRAM_BASE + DDR_BUFF_LEN - 8);
+
+	for (i = 0; i < DDR_BUFF_LEN / 8; i++)
+		*dst-- = *src--;
+
+	flush_dcache();
+}
+
+static void dp_resume_prepare(void)
+{
+	dp_ddr_restore();
+
+	board_sleep_prepare();
+
+	l2cache_init();
+#if defined(CONFIG_RAMBOOT_PBL)
+	disable_cpc_sram();
+#endif
+	enable_cpc();
+
+#ifdef CONFIG_U_QE
+	u_qe_resume();
+#endif
+}
+
+int fsl_dp_resume(void)
+{
+	u32 start_addr;
+	void (*kernel_resume)(void);
+	struct ccsr_scfg __iomem *scfg = (void *)CONFIG_SYS_MPC85xx_SCFG;
+
+	if (!is_warm_boot())
+		return 0;
+
+	dp_resume_prepare();
+
+	/* Get the entry address and jump to kernel */
+	start_addr = in_be32(&scfg->sparecr[1]);
+	debug("Entry address is 0x%08x\n", start_addr);
+	kernel_resume = (void (*)(void))start_addr;
+	kernel_resume();
+
+	return 0;
+}
diff --git a/board/tqc/tqmt2081/sleep.h b/board/tqc/tqmt2081/sleep.h
new file mode 100644
index 0000000..c26c542
--- /dev/null
+++ b/board/tqc/tqmt2081/sleep.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef __SLEEP_H
+#define __SLEEP_H
+
+#define DCFG_CCSR_CRSTSR_WDRFR	(1 << 3)
+#define DDR_BUFF_LEN			128
+
+/* determine if it is a wakeup from deep sleep */
+bool is_warm_boot(void);
+
+/* disable console output */
+void fsl_dp_disable_console(void);
+
+/* clean up everything and jump to kernel */
+int fsl_dp_resume(void);
+#endif
diff --git a/board/tqc/tqmt2081/spl.c b/board/tqc/tqmt2081/spl.c
new file mode 100644
index 0000000..9ae2b1e
--- /dev/null
+++ b/board/tqc/tqmt2081/spl.c
@@ -0,0 +1,107 @@
+/* Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <ns16550.h>
+#include <nand.h>
+#include <i2c.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <spi_flash.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+phys_size_t get_effective_memsize(void)
+{
+	return CONFIG_SYS_L3_SIZE;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	return CONFIG_SYS_CLK_FREQ;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	return CONFIG_DDR_CLK_FREQ;
+}
+
+void board_init_f(ulong bootflag)
+{
+	u32 plat_ratio, sys_clk, ccb_clk;
+	ccsr_gur_t *gur = (void *)CONFIG_SYS_MPC85xx_GUTS_ADDR;
+
+	/* Memcpy existing GD at CONFIG_SPL_GD_ADDR */
+	memcpy((void *)CONFIG_SPL_GD_ADDR, (void *)gd, sizeof(gd_t));
+
+	/* Update GD pointer */
+	gd = (gd_t *)(CONFIG_SPL_GD_ADDR);
+
+	console_init_f();
+
+	/* initialize selected port with appropriate baud rate */
+	sys_clk = get_board_sys_clk();
+	plat_ratio = (in_be32(&gur->rcwsr[0]) >> 25) & 0x1f;
+	ccb_clk = sys_clk * plat_ratio / 2;
+
+	NS16550_init((NS16550_t)CONFIG_SYS_NS16550_COM1,
+		     ccb_clk / 16 / CONFIG_BAUDRATE);
+
+#if defined(CONFIG_SPL_MMC_BOOT)
+	puts("\nSD boot...\n");
+#elif defined(CONFIG_SPL_SPI_BOOT)
+	puts("\nSPI boot...\n");
+#elif defined(CONFIG_SPL_NAND_BOOT)
+	puts("\nNAND boot...\n");
+#endif
+
+	relocate_code(CONFIG_SPL_RELOC_STACK, (gd_t *)CONFIG_SPL_GD_ADDR, 0x0);
+}
+
+void board_init_r(gd_t *gd, ulong dest_addr)
+{
+	bd_t *bd;
+
+	bd = (bd_t *)(gd + sizeof(gd_t));
+	memset(bd, 0, sizeof(bd_t));
+	gd->bd = bd;
+	bd->bi_memstart = CONFIG_SYS_INIT_L3_ADDR;
+	bd->bi_memsize = CONFIG_SYS_L3_SIZE;
+
+	probecpu();
+	get_clocks();
+	mem_malloc_init(CONFIG_SPL_RELOC_MALLOC_ADDR,
+			CONFIG_SPL_RELOC_MALLOC_SIZE);
+
+#ifdef CONFIG_SPL_NAND_BOOT
+	nand_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+			    (uchar *)CONFIG_ENV_ADDR);
+#endif
+#ifdef CONFIG_SPL_MMC_BOOT
+	mmc_initialize(bd);
+	mmc_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+			   (uchar *)CONFIG_ENV_ADDR);
+#endif
+#ifdef CONFIG_SPL_SPI_BOOT
+	spi_spl_load_image(CONFIG_ENV_OFFSET, CONFIG_ENV_SIZE,
+			   (uchar *)CONFIG_ENV_ADDR);
+#endif
+
+	gd->env_addr  = (ulong)(CONFIG_ENV_ADDR);
+	gd->env_valid = 1;
+
+	i2c_init_all();
+
+	gd->ram_size = initdram(0);
+
+#ifdef CONFIG_SPL_MMC_BOOT
+	mmc_boot();
+#elif defined(CONFIG_SPL_SPI_BOOT)
+	spi_boot();
+#elif defined(CONFIG_SPL_NAND_BOOT)
+	nand_boot();
+#endif
+}
diff --git a/board/tqc/tqmt2081/tlb.c b/board/tqc/tqmt2081/tlb.c
new file mode 100644
index 0000000..3e52c9f
--- /dev/null
+++ b/board/tqc/tqmt2081/tlb.c
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2008-2014 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS,
+		      MAS3_SX | MAS3_SW | MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 4 * 1024,
+		      MAS3_SX | MAS3_SW | MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 8 * 1024,
+		      MAS3_SX | MAS3_SW | MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 12 * 1024,
+		      MAS3_SX | MAS3_SW | MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+#if defined(CONFIG_SYS_RAMBOOT) && defined(CONFIG_SYS_INIT_L3_ADDR)
+	/*
+	 * *I*G - L3SRAM. When L3 is used as 1M SRAM, the address of the
+	 * SRAM is at 0xfff00000, it covered the 0xfffff000.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_INIT_L3_ADDR, CONFIG_SYS_INIT_L3_ADDR,
+		      MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
+		      0, 0, BOOKE_PAGESZ_1M, 1),
+#elif defined(CONFIG_SRIO_PCIE_BOOT_SLAVE)
+	/*
+	 * SRIO_PCIE_BOOT-SLAVE. When slave boot, the address of the
+	 * space is at 0xfff00000, it covered the 0xfffff000.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR,
+		      CONFIG_SYS_SRIO_PCIE_BOOT_SLAVE_ADDR_PHYS,
+		      MAS3_SX | MAS3_SW | MAS3_SR, MAS2_W | MAS2_G,
+		      0, 0, BOOKE_PAGESZ_1M, 1),
+#else
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+		      MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
+		      0, 0, BOOKE_PAGESZ_4K, 1),
+#endif
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+		      MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
+		      0, 1, BOOKE_PAGESZ_16M, 1),
+
+	/* *I*G* - Flash, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+		      MAS3_SX | MAS3_SR, MAS2_W | MAS2_G,
+		      0, 2, BOOKE_PAGESZ_256M, 1),
+
+#ifndef CONFIG_SPL_BUILD
+	/* *I*G* - PCIe 1, 0x80000000 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+		      MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
+		      0, 3, BOOKE_PAGESZ_512M, 1),
+
+	/* *I*G* - PCIe 2, 0xa0000000 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE2_MEM_VIRT, CONFIG_SYS_PCIE2_MEM_PHYS,
+		      MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
+		      0, 4, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCIe 3, 0xb0000000 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE3_MEM_VIRT, CONFIG_SYS_PCIE3_MEM_PHYS,
+		      MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
+		      0, 5, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCIe 4, 0xc0000000 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE4_MEM_VIRT, CONFIG_SYS_PCIE4_MEM_PHYS,
+		      MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
+		      0, 6, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCI I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+		      MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
+		      0, 7, BOOKE_PAGESZ_256K, 1),
+
+	/* Bman/Qman */
+#ifdef CONFIG_SYS_BMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE, CONFIG_SYS_BMAN_MEM_PHYS,
+		      MAS3_SX | MAS3_SW | MAS3_SR, 0,
+		      0, 9, BOOKE_PAGESZ_16M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_BMAN_MEM_BASE + 0x01000000,
+		      CONFIG_SYS_BMAN_MEM_PHYS + 0x01000000,
+		      MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
+		      0, 10, BOOKE_PAGESZ_16M, 1),
+#endif
+#ifdef CONFIG_SYS_QMAN_MEM_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE, CONFIG_SYS_QMAN_MEM_PHYS,
+		      MAS3_SX | MAS3_SW | MAS3_SR, 0,
+		      0, 11, BOOKE_PAGESZ_16M, 1),
+	SET_TLB_ENTRY(1, CONFIG_SYS_QMAN_MEM_BASE + 0x01000000,
+		      CONFIG_SYS_QMAN_MEM_PHYS + 0x01000000,
+		      MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
+		      0, 12, BOOKE_PAGESZ_16M, 1),
+#endif
+#endif
+#ifdef CONFIG_SYS_DCSRBAR_PHYS
+	SET_TLB_ENTRY(1, CONFIG_SYS_DCSRBAR, CONFIG_SYS_DCSRBAR_PHYS,
+		      MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
+		      0, 13, BOOKE_PAGESZ_32M, 1),
+#endif
+#ifdef CONFIG_SYS_NAND_BASE
+	/*
+	 * *I*G - NAND
+	 * entry 14 and 15 has been used hard coded, they will be disabled
+	 * in cpu_init_f, so we use entry 16 for nand.
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_NAND_BASE, CONFIG_SYS_NAND_BASE_PHYS,
+		      MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
+		      0, 16, BOOKE_PAGESZ_64K, 1),
+#endif
+#ifdef CONFIG_SYS_CPLD_BASE
+	SET_TLB_ENTRY(1, CONFIG_SYS_CPLD_BASE, CONFIG_SYS_CPLD_BASE_PHYS,
+		      MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
+		      0, 17, BOOKE_PAGESZ_4K, 1),
+#endif
+#ifdef CONFIG_SRIO_PCIE_BOOT_SLAVE
+	/*
+	 * SRIO_PCIE_BOOT-SLAVE. 1M space from 0xffe00000 for
+	 * fetching ucode and ENV from master
+	 */
+	SET_TLB_ENTRY(1, CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR,
+		      CONFIG_SYS_SRIO_PCIE_BOOT_UCODE_ENV_ADDR_PHYS,
+		      MAS3_SX | MAS3_SW | MAS3_SR, MAS2_G,
+		      0, 18, BOOKE_PAGESZ_1M, 1),
+#endif
+#if defined(CONFIG_RAMBOOT_PBL) && !defined(CONFIG_SPL_BUILD)
+	SET_TLB_ENTRY(1, CONFIG_SYS_DDR_SDRAM_BASE, CONFIG_SYS_DDR_SDRAM_BASE,
+		      MAS3_SX | MAS3_SW | MAS3_SR, 0,
+		      0, 19, BOOKE_PAGESZ_2G, 1)
+#endif
+
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
diff --git a/board/tqc/tqmt2081/tqmt2081.c b/board/tqc/tqmt2081/tqmt2081.c
new file mode 100644
index 0000000..757b575
--- /dev/null
+++ b/board/tqc/tqmt2081/tqmt2081.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * Based on board/freescale/t104xrdb/t104xrdb.c
+ *
+ * Copyright 2017 TQ Systems GmbH
+ *
+ * Author: Stefan Lange <s.lange@gateware.de>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <i2c.h>
+#include <netdev.h>
+#include <linux/compiler.h>
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_law.h>
+#include <asm/fsl_serdes.h>
+#include <asm/fsl_portals.h>
+#include <asm/fsl_liodn.h>
+#include <fm_eth.h>
+#include "tqmt2081.h"
+#include "vid.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	struct cpu_type *cpu = gd->arch.cpu;
+
+	printf("Board: TQM%s\n", cpu->name);
+
+	return 0;
+}
+
+int board_early_init_r(void)
+{
+#ifdef CONFIG_SYS_FLASH_BASE
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	int flash_esel = find_tlb_idx((void *)flashbase, 1);
+
+	/*
+	 * Remap Boot flash + PROMJET region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+	if (flash_esel == -1) {
+		/* very unlikely unless something is messed up */
+		puts("Error: Could not find TLB for FLASH BASE\n");
+		flash_esel = 2;	/* give our best effort to continue */
+	} else {
+		/* invalidate existing TLB entry for flash + promjet */
+		disable_tlb(flash_esel);
+	}
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+		MAS3_SX | MAS3_SW | MAS3_SR, MAS2_I | MAS2_G,
+		0, flash_esel, BOOKE_PAGESZ_256M, 1);
+#endif
+	set_liodns();
+#ifdef CONFIG_SYS_DPAA_QBMAN
+	setup_portals();
+#endif
+
+	/* Adjust core voltage according to voltage ID */
+	if (adjust_vdd())
+		printf("Warning: Adjusting core voltage failed.\n");
+	return 0;
+}
+
+int misc_init_r(void)
+{
+	return 0;
+}
+
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	phys_addr_t base;
+	phys_size_t size;
+
+	ft_cpu_setup(blob, bd);
+
+	base = getenv_bootm_low();
+	size = getenv_bootm_size();
+
+	fdt_fixup_memory(blob, (u64)base, (u64)size);
+
+#ifdef CONFIG_PCI
+	pci_of_setup(blob, bd);
+#endif
+
+	fdt_fixup_liodn(blob);
+	fdt_fixup_dr_usb(blob, bd);
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+	fdt_fixup_fman_ethernet(blob);
+	fdt_fixup_board_enet(blob);
+#endif
+
+	return 0;
+}
diff --git a/board/tqc/tqmt2081/tqmt2081.h b/board/tqc/tqmt2081/tqmt2081.h
new file mode 100644
index 0000000..13380d0
--- /dev/null
+++ b/board/tqc/tqmt2081/tqmt2081.h
@@ -0,0 +1,13 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CORENET_DS_H__
+#define __CORENET_DS_H__
+
+void fdt_fixup_board_enet(void *blob);
+void pci_of_setup(void *blob, bd_t *bd);
+
+#endif
diff --git a/board/tqc/tqmt2081/tqmt2081_pbi.cfg b/board/tqc/tqmt2081/tqmt2081_pbi.cfg
new file mode 100644
index 0000000..e200d92
--- /dev/null
+++ b/board/tqc/tqmt2081/tqmt2081_pbi.cfg
@@ -0,0 +1,41 @@
+#
+# Copyright 2013 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+# Refer doc/README.pblimage for more details about how-to configure
+# and create PBL boot image
+#
+
+#PBI commands
+#Initialize CPC1
+09010000 00200400
+09138000 00000000
+091380c0 00000100
+#512KB SRAM
+09010100 00000000
+09010104 fff80009
+09010f00 08000000
+#enable CPC1
+09010000 80000000
+#Configure LAW for CPC1
+09000d00 00000000
+09000d04 fff80000
+09000d08 81000012
+#Initialize eSPI controller, default configuration is slow for eSPI to
+#load data, this configuration comes from u-boot eSPI driver.
+09110000 80000403
+09110020 2d170008
+09110024 00100008
+09110028 00100008
+0911002c 00100008
+#Errata for slowing down the MDC clock to make it <= 2.5 MHZ
+094fc030 00008148
+094fd030 00008148
+#Configure alternate space
+09000010 00000000
+09000014 ff000000
+09000018 81000000
+#Flush PBL data
+09138000 00000000
+091380c0 00000000
diff --git a/board/tqc/tqmt2081/tqmt2081_serdes71_rcw.cfg b/board/tqc/tqmt2081/tqmt2081_serdes71_rcw.cfg
new file mode 100644
index 0000000..38dbaa1
--- /dev/null
+++ b/board/tqc/tqmt2081/tqmt2081_serdes71_rcw.cfg
@@ -0,0 +1,9 @@
+#PBL preamble and RCW header
+aa55aa55 010e0100
+
+#SerDes=0x71_0x15, Core:1800MHz, DDR:1867MT/s TODO
+0C0E0012 12000000 00000000 00000000
+71000002 80000001 EC027000 01000000
+00000000 00000000 00000000 0001A800
+00000000 01565005 00000000 00000000
+
diff --git a/board/tqc/tqmt2081/tqmt2081_serdesf2_rcw.cfg b/board/tqc/tqmt2081/tqmt2081_serdesf2_rcw.cfg
new file mode 100644
index 0000000..8096ff9
--- /dev/null
+++ b/board/tqc/tqmt2081/tqmt2081_serdesf2_rcw.cfg
@@ -0,0 +1,19 @@
+#PBL preamble and RCW header
+aa55aa55 010e0100
+
+#For T2080 v1.0
+#SerDes=0x66_0x16, Core=1533MHz, DDR=1600MT/s
+#120c0017 15000000 00000000 00000000
+#66150002 00008400 ec104000 c1000000
+#00000000 00000000 00000000 000307fc
+#00000000 00000000 00000000 00000004
+
+#For T2080 v1.1
+#SerDes=0x66_0x15, Core:1800MHz, DDR:1600MT/s
+#1206001b 15000000 00000000 00000000
+
+#SerDes=0x66_0x15, Core:1800MHz, DDR:1867MT/s
+1207001b 15000000 00000000 00000000
+66150002 00000000 e8104000 c1000000
+00800000 00000000 00000000 000307fc
+00000000 00000000 00000000 00000004
diff --git a/board/tqc/tqmt2081/vid.c b/board/tqc/tqmt2081/vid.c
new file mode 100644
index 0000000..039adb3
--- /dev/null
+++ b/board/tqc/tqmt2081/vid.c
@@ -0,0 +1,136 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * Based on board/freescale/common/vid.c
+ *
+ * Copyright 2017 TQ Systems GmbH
+ *
+ * Author: Stefan Lange <s.lange@gateware.de>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <i2c.h>
+
+#define SYSCTRLUC_I2C_ADDR		0x11
+#define SYSCTRLUC_I2C_REG_VID_VALUE	0x09
+
+/* helper sleep function */
+static void usleep(int i)
+{
+/* CPU core clock: 1800 MhZ => 0,55ns */
+#define CPU_TICKS_PER_US 2000
+
+	int z;
+
+	for (z = 0; z < (i * CPU_TICKS_PER_US); z++) {
+		/* do nothing */
+	}
+}
+
+/*
+ * set voltage via writing to system microcontroller (uC)
+ *
+ * The uC acts as an I2C Device. The desired VID value must be
+ * written to SYSCTRL_I2C_REG_VID_VALUE. The uC then alters the
+ * DC/DC converters output voltage by superseding a PWM signal
+ * on the DC/DC convertres FB pin.
+ */
+static int set_voltage(u8 vid)
+{
+	int ret;
+
+	/* write to uC I2C register */
+	ret = i2c_write(SYSCTRLUC_I2C_ADDR, SYSCTRLUC_I2C_REG_VID_VALUE,
+			1, (void *)&vid, sizeof(vid));
+
+	return ret;
+}
+
+int adjust_vdd(void)
+{
+	ccsr_gur_t __iomem *gur =
+		(void __iomem *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	u32 fusesr;
+	u8 vid;
+	int vdd_target;
+	int ret;
+	static const uint16_t vdd[32] = {
+		0,      /* unused */
+		9875,   /* 0.9875V */
+		9750,
+		9625,
+		9500,
+		9375,
+		9250,
+		9125,
+		9000,
+		8875,
+		8750,
+		8625,
+		8500,
+		8375,
+		8250,
+		8125,
+		10000,  /* 1.0000V */
+		10125,
+		10250,
+		10375,
+		10500,
+		10625,
+		10750,
+		10875,
+		11000,
+		0,      /* reserved */
+	};
+
+	/* get the voltage ID from fuse status register */
+	fusesr = in_be32(&gur->dcfg_fusesr);
+	/*
+	 * VID is used according to the table below
+	 *                ---------------------------------------
+	 *                |                DA_V                 |
+	 *                |-------------------------------------|
+	 *                | 5b00000 | 5b00001-5b11110 | 5b11111 |
+	 * ---------------+---------+-----------------+---------|
+	 * | D | 5b00000  | NO VID  | VID = DA_V      | NO VID  |
+	 * | A |----------+---------+-----------------+---------|
+	 * | _ | 5b00001  |VID =    | VID =           |VID =    |
+	 * | V |   ~      | DA_V_ALT|   DA_V_ALT      | DA_A_VLT|
+	 * | _ | 5b11110  |         |                 |         |
+	 * | A |----------+---------+-----------------+---------|
+	 * | L | 5b11111  | No VID  | VID = DA_V      | NO VID  |
+	 * | T |          |         |                 |         |
+	 * ------------------------------------------------------
+	 */
+	vid = (fusesr >> FSL_CORENET_DCFG_FUSESR_ALTVID_SHIFT) &
+	       FSL_CORENET_DCFG_FUSESR_ALTVID_MASK;
+	if ((vid == 0) || (vid == FSL_CORENET_DCFG_FUSESR_ALTVID_MASK)) {
+		vid = (fusesr >> FSL_CORENET_DCFG_FUSESR_VID_SHIFT) &
+		FSL_CORENET_DCFG_FUSESR_VID_MASK;
+	}
+	vdd_target = vdd[vid];
+
+	if (vdd_target == 0) {
+		printf("VID: VID value invalid, not used\n");
+		return -1;
+	}
+
+	/* set voltage to fused vid value */
+	ret = set_voltage(vid);
+
+	if (ret < 0) {
+		printf("VID: error on setting VID voltage\n");
+		return -1;
+	}
+
+	/* wait for value to settle */
+	usleep(1000);
+
+	/* divide and round up by 10 to get a value in mV */
+	vdd_target = DIV_ROUND_UP(vdd_target, 10);
+	printf("VID: voltage set to vid = %d mV\n", vdd_target);
+
+	return 0;
+}
diff --git a/board/tqc/tqmt2081/vid.h b/board/tqc/tqmt2081/vid.h
new file mode 100644
index 0000000..4b41c2b
--- /dev/null
+++ b/board/tqc/tqmt2081/vid.h
@@ -0,0 +1,14 @@
+/*
+ * Copyright 2017 TQ Systems GmbH
+ *
+ * Author: Stefan Lange <s.lange@gateware.de>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __VID_H_
+#define __VID_H_
+
+int adjust_vdd(void);
+
+#endif  /* __VID_H_ */
diff --git a/include/configs/TQMT2081.h b/include/configs/TQMT2081.h
new file mode 100644
index 0000000..6ab4ad5
--- /dev/null
+++ b/include/configs/TQMT2081.h
@@ -0,0 +1,666 @@
+/*
+ * Copyright 2017 TQ Systems GmbH
+ *
+ * Author: Stefan Lange <s.lange@gateware.de>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __CONFIG_TQMT2081_H
+#define __CONFIG_TQMT2081_H
+
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_BOARDINFO
+#define CONFIG_MMC
+#define CONFIG_USB_EHCI
+#define CONFIG_FSL_SATA_V2
+
+/* High Level Configuration Options */
+#define CONFIG_PHYS_64BIT
+#define CONFIG_BOOKE
+#define CONFIG_E500		/* BOOKE e500 family */
+#define CONFIG_E500MC		/* BOOKE e500mc family */
+#define CONFIG_SYS_BOOK3E_HV	/* Category E.HV supported */
+#define CONFIG_MP		/* support multiple processors */
+#define CONFIG_ENABLE_36BIT_PHYS
+
+#ifdef CONFIG_PHYS_64BIT
+#define CONFIG_ADDR_MAP 1
+#define CONFIG_SYS_NUM_ADDR_MAP 64 /* number of TLB1 entries */
+#endif
+
+#define CONFIG_SYS_FSL_CPC	/* Corenet Platform Cache */
+#define CONFIG_SYS_NUM_CPC	CONFIG_NUM_DDR_CONTROLLERS
+#define CONFIG_FSL_IFC		/* Enable IFC Support */
+#define CONFIG_FSL_CAAM		/* Enable SEC/CAAM */
+#define CONFIG_FSL_LAW		/* Use common FSL init code */
+#define CONFIG_ENV_OVERWRITE
+
+#ifdef CONFIG_RAMBOOT_PBL
+
+#define CONFIG_SYS_FSL_PBL_PBI board/tqc/tqmt2081/tqmt2081_pbi.cfg
+ /* use same configuration for RAMBOOT and NOR boot */
+#define CONFIG_SYS_FSL_PBL_RCW CONFIG_SYS_FSL_RCW
+#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_FLUSH_IMAGE
+#define CONFIG_SPL_TARGET		"u-boot-with-spl.bin"
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_DRIVERS_MISC_SUPPORT
+#define CONFIG_FSL_LAW			/* Use common FSL init code */
+#define CONFIG_SYS_TEXT_BASE		0x00201000
+#define CONFIG_SPL_TEXT_BASE		0xFFFD8000
+#define CONFIG_SPL_PAD_TO		0x40000
+#define CONFIG_SPL_MAX_SIZE		0x28000
+#define RESET_VECTOR_OFFSET		0x27FFC
+#define BOOT_PAGE_OFFSET		0x27000
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SPL_SKIP_RELOCATE
+#define CONFIG_SPL_COMMON_INIT_DDR
+#define CONFIG_SYS_CCSR_DO_NOT_RELOCATE
+#define CONFIG_SYS_NO_FLASH
+#endif /* CONFIG_SPL_BUILD */
+
+#ifdef CONFIG_SDCARD
+#define CONFIG_RESET_VECTOR_ADDRESS             0x200FFC
+#define CONFIG_SPL_MMC_SUPPORT
+#define CONFIG_SPL_MMC_MINIMAL
+#define CONFIG_SYS_MMC_U_BOOT_SIZE     (768 << 10)
+#define CONFIG_SYS_MMC_U_BOOT_DST      (0x00200000)
+#define CONFIG_SYS_MMC_U_BOOT_START    (0x00200000)
+#define CONFIG_SYS_MMC_U_BOOT_OFFS     (260 << 10)
+#define CONFIG_SYS_LDSCRIPT    "arch/powerpc/cpu/mpc85xx/u-boot.lds"
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MPC85XX_NO_RESETVEC
+#endif /* CONFIG_SPL_BUILD */
+#define CONFIG_SPL_MMC_BOOT
+#endif /* CONFIG_SDCARD */
+#else
+#define CONFIG_FSL_RCW_BIN
+
+#endif /* CONFIG_RAMBOOT_PBL */
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE	0xeff40000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS	0xeffffffc
+#endif
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_SYS_CACHE_STASHING
+#define CONFIG_BTB		/* toggle branch predition */
+#define CONFIG_DDR_ECC
+#ifdef CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE		0xdeadbeef
+#endif
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x00200000 /* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x00400000
+#define CONFIG_SYS_ALT_MEMTEST
+
+#ifndef CONFIG_SYS_NO_FLASH
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#endif
+
+#if defined(CONFIG_SDCARD)
+#define CONFIG_SYS_EXTRA_ENV_RELOC
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_SYS_MMC_ENV_DEV	0
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_OFFSET	(512 * 0x800)
+#elif defined(CONFIG_ENV_IS_NOWHERE)
+#define CONFIG_ENV_SIZE		0x2000
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_SECT_SIZE	0x20000 /* 128K (one sector) */
+#endif
+
+#ifndef __ASSEMBLY__
+unsigned long get_board_sys_clk(void);
+unsigned long get_board_ddr_clk(void);
+#endif
+
+#define CONFIG_SYS_CLK_FREQ     100000000
+#define CONFIG_DDR_CLK_FREQ     133333300
+
+/*
+ * Config the L3 Cache as L3 SRAM
+ */
+#define CONFIG_SYS_INIT_L3_ADDR		0xFFFC0000
+#define CONFIG_SYS_L3_SIZE		(512 << 10)
+#define CONFIG_SPL_GD_ADDR		(CONFIG_SYS_INIT_L3_ADDR + 32 * 1024)
+#ifdef CONFIG_RAMBOOT_PBL
+#define CONFIG_ENV_ADDR			(CONFIG_SPL_GD_ADDR + 4 * 1024)
+#endif
+#define CONFIG_SPL_RELOC_MALLOC_ADDR	(CONFIG_SPL_GD_ADDR + 12 * 1024)
+#define CONFIG_SPL_RELOC_MALLOC_SIZE	(50 << 10)
+#define CONFIG_SPL_RELOC_STACK		(CONFIG_SPL_GD_ADDR + 64 * 1024)
+#define CONFIG_SPL_RELOC_STACK_SIZE	(22 << 10)
+
+#define CONFIG_SYS_DCSRBAR	0xf0000000
+#define CONFIG_SYS_DCSRBAR_PHYS	0xf00000000ull
+
+/*
+ * DDR Setup
+ */
+#define CONFIG_VERY_BIG_RAM
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	(1 * CONFIG_DIMM_SLOTS_PER_CTLR)
+#define CONFIG_SYS_SDRAM_SIZE	2048		/* for fixed parameter use */
+/*
+ * Use fixed DDR timing
+ *
+ * DDR_RAW_TIMING was only used for bringup/debugging.
+ * If DDR_RAW_TIMING shall be used for testing purposes, define
+ * CONFIG_SYS_DDR_RAW_TIMING here.
+ */
+#define CONFIG_SYS_DDR_RAW_TIMING
+#ifdef CONFIG_SYS_DDR_RAW_TIMING
+#define CONFIG_FSL_DDR_INTERACTIVE
+#define CONFIG_SYS_FSL_DDR3
+#endif
+
+/*
+ * IFC Definitions
+ */
+#define CONFIG_SYS_FLASH_BASE		0xe8000000
+#define CONFIG_SYS_FLASH_BASE_PHYS	(0xf00000000ull | CONFIG_SYS_FLASH_BASE)
+#define CONFIG_SYS_NOR_CSPR_EXT	(0xf)
+#define CONFIG_SYS_NOR_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | \
+				CSPR_PORT_SIZE_16 | \
+				CSPR_MSEL_NOR | \
+				CSPR_V)
+#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(128*1024*1024)
+
+/* NOR Flash Timing Params */
+#define CONFIG_SYS_NOR_CSOR     CSOR_NOR_TRHZ_20
+#define CONFIG_SYS_NOR_FTIM0    (FTIM0_NOR_TACSE(0x1) | \
+				FTIM0_NOR_TEADC(0x4) | \
+				FTIM0_NOR_TEAHC(0x3))
+#define CONFIG_SYS_NOR_FTIM1    (FTIM1_NOR_TACO(0x1) | \
+				FTIM1_NOR_TRAD_NOR(0x27) |\
+				FTIM1_NOR_TSEQRAD_NOR(0x00))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x1) | \
+				FTIM2_NOR_TCH(0x1) | \
+				FTIM2_NOR_TWPH(0x00) | \
+				FTIM2_NOR_TWP(0x21))
+#define CONFIG_SYS_NOR_FTIM3	0x0
+
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE_PHYS }
+
+#define CONFIG_SYS_CSPR0_EXT            CONFIG_SYS_NOR_CSPR_EXT
+#define CONFIG_SYS_CSPR0                CONFIG_SYS_NOR_CSPR
+#define CONFIG_SYS_AMASK0               CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0                CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0            CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1            CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2            CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3            CONFIG_SYS_NOR_FTIM3
+
+#if defined(CONFIG_RAMBOOT_PBL)
+#define CONFIG_SYS_RAMBOOT
+#endif
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SYS_MONITOR_BASE  CONFIG_SPL_TEXT_BASE
+#else
+#define CONFIG_SYS_MONITOR_BASE  CONFIG_SYS_TEXT_BASE /* start of monitor */
+#endif
+
+#define CONFIG_BOARD_EARLY_INIT_R	/* call board_early_init_r function */
+#define CONFIG_MISC_INIT_R
+#define CONFIG_HWCONFIG
+
+/* define to use L1 as initial stack */
+#define CONFIG_L1_INIT_RAM
+#define CONFIG_SYS_INIT_RAM_LOCK
+#define CONFIG_SYS_INIT_RAM_ADDR	0xfdd00000 /* Initial L1 address */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH	0xf
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW	0xfe0ec000
+/* The assembler doesn't like typecast */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS \
+			((CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH * 1ull << 32) | \
+			CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW)
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00004000
+#define CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_INIT_RAM_SIZE - \
+						GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+#define CONFIG_SYS_MONITOR_LEN		(768 * 1024)
+#define CONFIG_SYS_MALLOC_LEN		(4 * 1024 * 1024)
+
+/*
+ * Serial Port
+ */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		(get_bus_freq(0)/2)
+#define CONFIG_SYS_BAUDRATE_TABLE	\
+	{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200}
+#define CONFIG_SYS_NS16550_COM1 (CONFIG_SYS_CCSRBAR+0x11C500)
+#define CONFIG_SYS_NS16550_COM2 (CONFIG_SYS_CCSRBAR+0x11C600)
+#define CONFIG_SYS_NS16550_COM3 (CONFIG_SYS_CCSRBAR+0x11D500)
+#define CONFIG_SYS_NS16550_COM4 (CONFIG_SYS_CCSRBAR+0x11D600)
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+
+/* pass open firmware flat tree */
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+#define CONFIG_OF_STDOUT_VIA_ALIAS
+
+/* new uImage format support */
+#define CONFIG_FIT
+#define CONFIG_FIT_VERBOSE	/* enable fit_format_{error,warning}() */
+
+/*
+ * I2C
+ */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_FSL
+#define CONFIG_SYS_FSL_I2C_SLAVE   0x7F
+#define CONFIG_SYS_FSL_I2C2_SLAVE  0x7F
+#define CONFIG_SYS_FSL_I2C3_SLAVE  0x7F
+#define CONFIG_SYS_FSL_I2C4_SLAVE  0x7F
+#define CONFIG_SYS_FSL_I2C_OFFSET  0x118000
+#define CONFIG_SYS_FSL_I2C2_OFFSET 0x118100
+#define CONFIG_SYS_FSL_I2C3_OFFSET 0x119000
+#define CONFIG_SYS_FSL_I2C4_OFFSET 0x119100
+#define CONFIG_SYS_FSL_I2C_SPEED   100000
+#define CONFIG_SYS_FSL_I2C2_SPEED  100000
+#define CONFIG_SYS_FSL_I2C3_SPEED  100000
+#define CONFIG_SYS_FSL_I2C4_SPEED  100000
+
+#define CONFIG_VID_FLS_ENV		"t208xrdb_vdd_mv"
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_VID
+#endif
+#define CONFIG_VOL_MONITOR_IR36021_SET
+#define CONFIG_VOL_MONITOR_IR36021_READ
+/* The lowest and highest voltage allowed for T208xRDB */
+#define VDD_MV_MIN			819
+#define VDD_MV_MAX			1212
+
+/*
+ * General PCI
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+#define CONFIG_PCI		/* Enable PCI/PCIE */
+#define CONFIG_PCIE1		/* PCIE controller 1 */
+#define CONFIG_PCIE2		/* PCIE controller 2 */
+#define CONFIG_PCIE3		/* PCIE controller 3 */
+#define CONFIG_PCIE4		/* PCIE controller 4 */
+#define CONFIG_FSL_PCI_INIT	/* Use common FSL init code */
+#define CONFIG_SYS_PCI_64BIT	/* enable 64-bit PCI resources */
+/* controller 1, direct to uli, tgtid 3, Base address 20000 */
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0x80000000
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xc00000000ull
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000      /* 512M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xf8000000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xff8000000ull
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64k */
+
+/* controller 2, Slot 2, tgtid 2, Base address 201000 */
+#define CONFIG_SYS_PCIE2_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCIE2_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE2_MEM_PHYS	0xc20000000ull
+#define CONFIG_SYS_PCIE2_MEM_SIZE	0x10000000 /* 256M */
+#define CONFIG_SYS_PCIE2_IO_VIRT	0xf8010000
+#define CONFIG_SYS_PCIE2_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE2_IO_PHYS	0xff8010000ull
+#define CONFIG_SYS_PCIE2_IO_SIZE	0x00010000	/* 64k */
+
+/* controller 3, Slot 1, tgtid 1, Base address 202000 */
+#define CONFIG_SYS_PCIE3_MEM_VIRT	0xb0000000
+#define CONFIG_SYS_PCIE3_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE3_MEM_PHYS	0xc30000000ull
+#define CONFIG_SYS_PCIE3_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE3_IO_VIRT	0xf8020000
+#define CONFIG_SYS_PCIE3_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE3_IO_PHYS	0xff8020000ull
+#define CONFIG_SYS_PCIE3_IO_SIZE	0x00010000	/* 64k */
+
+/* controller 4, Base address 203000 */
+#define CONFIG_SYS_PCIE4_MEM_VIRT       0xc0000000
+#define CONFIG_SYS_PCIE4_MEM_BUS	0xe0000000
+#define CONFIG_SYS_PCIE4_MEM_PHYS	0xc40000000ull
+#define CONFIG_SYS_PCIE4_MEM_SIZE	0x10000000	/* 256M */
+#define CONFIG_SYS_PCIE4_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE4_IO_PHYS	0xff8030000ull
+#define CONFIG_SYS_PCIE4_IO_SIZE	0x00010000	/* 64k */
+
+#ifdef CONFIG_PCI
+#define CONFIG_PCI_INDIRECT_BRIDGE
+#define CONFIG_FSL_PCIE_RESET           /* need PCIe reset errata LSZ ADD */
+#define CONFIG_E1000
+#define CONFIG_PCI_PNP		/* do pci plug-and-play */
+#define CONFIG_PCI_SCAN_SHOW	/* show pci devices on startup */
+#define CONFIG_DOS_PARTITION
+#endif
+
+/* Qman/Bman */
+#ifndef CONFIG_NOBQFMAN
+#define CONFIG_SYS_DPAA_QBMAN		/* Support Q/Bman */
+#define CONFIG_SYS_BMAN_NUM_PORTALS	18
+#define CONFIG_SYS_BMAN_MEM_BASE	0xf4000000
+#define CONFIG_SYS_BMAN_MEM_PHYS	0xff4000000ull
+#define CONFIG_SYS_BMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_BMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_BMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_BMAN_CENA_BASE       CONFIG_SYS_BMAN_MEM_BASE
+#define CONFIG_SYS_BMAN_CENA_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_CINH_BASE       (CONFIG_SYS_BMAN_MEM_BASE + \
+					CONFIG_SYS_BMAN_CENA_SIZE)
+#define CONFIG_SYS_BMAN_CINH_SIZE       (CONFIG_SYS_BMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_BMAN_SWP_ISDR_REG	0xE08
+#define CONFIG_SYS_QMAN_NUM_PORTALS	18
+#define CONFIG_SYS_QMAN_MEM_BASE	0xf6000000
+#define CONFIG_SYS_QMAN_MEM_PHYS	0xff6000000ull
+#define CONFIG_SYS_QMAN_MEM_SIZE	0x02000000
+#define CONFIG_SYS_QMAN_SP_CENA_SIZE    0x4000
+#define CONFIG_SYS_QMAN_SP_CINH_SIZE    0x1000
+#define CONFIG_SYS_QMAN_CENA_BASE       CONFIG_SYS_QMAN_MEM_BASE
+#define CONFIG_SYS_QMAN_CENA_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_CINH_BASE       (CONFIG_SYS_QMAN_MEM_BASE + \
+					CONFIG_SYS_QMAN_CENA_SIZE)
+#define CONFIG_SYS_QMAN_CINH_SIZE       (CONFIG_SYS_QMAN_MEM_SIZE >> 1)
+#define CONFIG_SYS_QMAN_SWP_ISDR_REG	0xE08
+
+#define CONFIG_SYS_DPAA_FMAN
+#define CONFIG_SYS_DPAA_PME
+#define CONFIG_SYS_PMAN
+#define CONFIG_SYS_DPAA_DCE
+#define CONFIG_SYS_DPAA_RMAN		/* RMan */
+#define CONFIG_SYS_INTERLAKEN
+
+#if defined(CONFIG_SDCARD)
+/*
+ * PBL SD boot image should stored at 0x1000(8 blocks), the size of the image is
+ * about 1MB (2048 blocks), Env is stored after the image, and the env size is
+ * 0x2000 (16 blocks), 8 + 2048 + 16 = 2072, enlarge it to 2080.
+ */
+#define CONFIG_SYS_QE_FMAN_FW_IN_MMC
+#define CONFIG_SYS_FMAN_FW_ADDR		(512 * 0x820)
+#else
+#define CONFIG_SYS_QE_FMAN_FW_IN_NOR
+#define CONFIG_SYS_FMAN_FW_ADDR		0xEFF00000
+#endif
+
+#if defined(CONFIG_SDCARD)
+#define CONFIG_SYS_QE_FW_ADDR           (512 * 0x920)
+#else
+#define CONFIG_SYS_QE_FW_ADDR           0xEFF10000
+#endif
+
+#define CONFIG_SYS_QE_FMAN_FW_LENGTH	0x10000
+#define CONFIG_SYS_FDT_PAD		(0x3000 + CONFIG_SYS_QE_FMAN_FW_LENGTH)
+#endif /* CONFIG_NOBQFMAN */
+
+#ifdef CONFIG_SYS_DPAA_FMAN
+#define CONFIG_FMAN_ENET
+#define CONFIG_PHY_VITESSE
+#define CONFIG_PHYLIB_10G
+#endif
+
+#ifdef CONFIG_FMAN_ENET
+#define CONFIG_SYS_SGMII1_PHY_ADDR              0x1D
+#define CONFIG_SYS_SGMII2_PHY_ADDR              0x03
+#define CONFIG_SYS_SGMII5_PHY_ADDR              0x01
+#define CONFIG_SYS_RGMII1_PHY_ADDR              0x0E
+#define CONFIG_SYS_RGMII2_PHY_ADDR              0x05
+#endif
+
+#ifdef CONFIG_FMAN_ENET
+#define CONFIG_MII		/* MII PHY management */
+#define CONFIG_ETHPRIME		"FM1@DTSEC3"
+#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+#endif
+
+/*
+ * SATA
+ */
+#ifdef CONFIG_FSL_SATA_V2
+#define CONFIG_LIBATA
+#define CONFIG_FSL_SATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	2
+#define CONFIG_SATA1
+#define CONFIG_SYS_SATA1		CONFIG_SYS_MPC85xx_SATA1_ADDR
+#define CONFIG_SYS_SATA1_FLAGS		FLAGS_DMA
+#define CONFIG_SATA2
+#define CONFIG_SYS_SATA2		CONFIG_SYS_MPC85xx_SATA2_ADDR
+#define CONFIG_SYS_SATA2_FLAGS		FLAGS_DMA
+#define CONFIG_LBA48
+#define CONFIG_CMD_SATA
+#define CONFIG_DOS_PARTITION
+#define CONFIG_CMD_EXT2
+#endif
+
+/*
+ * USB
+ */
+#ifdef CONFIG_USB_EHCI
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_EHCI_FSL
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_CMD_EXT2
+#define CONFIG_HAS_FSL_DR_USB
+#endif
+
+/*
+ * SDHC
+ */
+#ifdef CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	CONFIG_SYS_MPC85xx_ESDHC_ADDR
+#define CONFIG_SYS_FSL_ESDHC_BROKEN_TIMEOUT
+#define CONFIG_SYS_FSL_MMC_HAS_CAPBLT_VS33
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+/*
+ * Dynamic MTD Partition support with mtdparts
+ */
+#ifndef CONFIG_SYS_NO_FLASH
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_FLASH_CFI_MTD
+#define MTDIDS_DEFAULT "nor0=fe8000000.nor"
+#define MTDPARTS_DEFAULT "mtdparts=fe8000000.nor:1m(uboot),5m(kernel)," \
+			"128k(dtb),96m(fs),-(user);"
+#endif
+
+/*
+ * Environment
+ */
+
+/*
+ * Command line configuration.
+ */
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_ERRATA
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_REGINFO
+
+#ifdef CONFIG_PCI
+#define CONFIG_CMD_PCI
+#endif
+
+/* Hash command with SHA acceleration supported in hardware */
+#ifdef CONFIG_FSL_CAAM
+#define CONFIG_CMD_HASH
+#define CONFIG_SHA_HW_ACCEL
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_CMDLINE_EDITING		/* Command-line editing */
+#define CONFIG_AUTO_COMPLETE		/* add autocompletion support */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000 /* default load address */
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_SYS_CBSIZE	1024	  /* Console I/O Buffer Size */
+#else
+#define CONFIG_SYS_CBSIZE	1024	  /* Console I/O Buffer Size */
+#endif
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+#define CONFIG_SYS_MAXARGS	16	/* max number of command args */
+#define CONFIG_SYS_BARGSIZE	CONFIG_SYS_CBSIZE/* Boot Argument Buffer Size */
+
+/*
+ * For booting Linux, the board info and command line data
+ * have to be in the first 64 MB of memory, since this is
+ * the maximum mapped by the Linux kernel during initialization.
+ */
+#define CONFIG_SYS_BOOTMAPSZ	(64 << 20)	/* Initial map for Linux*/
+#define CONFIG_SYS_BOOTM_LEN	(64 << 20)	/* Increase max gunzip size */
+
+#ifdef CONFIG_CMD_KGDB
+#define CONFIG_KGDB_BAUDRATE	230400	/* speed to run kgdb serial port */
+#define CONFIG_KGDB_SER_INDEX	2	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+#define CONFIG_ROOTPATH	 "/opt/nfsroot"
+#define CONFIG_BOOTFILE	 "uImage"
+#define CONFIG_UBOOTPATH "u-boot.bin"	/* U-Boot image on TFTP server */
+
+/* default location for tftp and bootm */
+#define CONFIG_LOADADDR		1000000
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_BOOTDELAY	10	/* -1 disables auto-boot */
+#define __USB_PHY_TYPE		utmi
+
+#define	CONFIG_EXTRA_ENV_SETTINGS				\
+	"hwconfig=fsl_ddr:"					\
+	"ctlr_intlv=" __stringify(CTRL_INTLV_PREFERED) ","	\
+	"bank_intlv=auto;"					\
+	"usb1:dr_mode=host,phy_type=" __stringify(__USB_PHY_TYPE) "\0"\
+	"netdev=eth0\0"						\
+	"uboot=" __stringify(CONFIG_UBOOTPATH) "\0"		\
+	"ubootaddr=" __stringify(CONFIG_SYS_TEXT_BASE) "\0"	\
+	"tftpflash=tftpboot $loadaddr $uboot && "		\
+	"protect off $ubootaddr +$filesize && "			\
+	"erase $ubootaddr +$filesize && "			\
+	"cp.b $loadaddr $ubootaddr $filesize && "		\
+	"protect on $ubootaddr +$filesize && "			\
+	"cmp.b $loadaddr $ubootaddr $filesize\0"		\
+	"consoledev=ttyS0\0"					\
+	"ramdiskaddr=2000000\0"					\
+	"ramdiskfile=t2080rdb/ramdisk.uboot\0"			\
+	"fdtaddr=c00000\0"					\
+	"fdtfile=t2080rdb/t2080rdb.dtb\0"			\
+	"bdev=sda3\0"
+
+/*
+ * For emulation this causes u-boot to jump to the start of the
+ * proof point app code automatically
+ */
+#define CONFIG_PROOF_POINTS				\
+	"setenv bootargs root=/dev/$bdev rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"cpu 1 release 0x29000000 - - -;"		\
+	"cpu 2 release 0x29000000 - - -;"		\
+	"cpu 3 release 0x29000000 - - -;"		\
+	"cpu 4 release 0x29000000 - - -;"		\
+	"cpu 5 release 0x29000000 - - -;"		\
+	"cpu 6 release 0x29000000 - - -;"		\
+	"cpu 7 release 0x29000000 - - -;"		\
+	"go 0x29000000"
+
+#define CONFIG_HVBOOT				\
+	"setenv bootargs config-addr=0x60000000; "	\
+	"bootm 0x01000000 - 0x00f00000"
+
+#define CONFIG_ALU				\
+	"setenv bootargs root=/dev/$bdev rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"cpu 1 release 0x01000000 - - -;"		\
+	"cpu 2 release 0x01000000 - - -;"		\
+	"cpu 3 release 0x01000000 - - -;"		\
+	"cpu 4 release 0x01000000 - - -;"		\
+	"cpu 5 release 0x01000000 - - -;"		\
+	"cpu 6 release 0x01000000 - - -;"		\
+	"cpu 7 release 0x01000000 - - -;"		\
+	"go 0x01000000"
+
+#define CONFIG_LINUX				\
+	"setenv bootargs root=/dev/ram rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"setenv ramdiskaddr 0x02000000;"		\
+	"setenv fdtaddr 0x00c00000;"			\
+	"setenv loadaddr 0x1000000;"			\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_HDBOOT					\
+	"setenv bootargs root=/dev/$bdev rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"			\
+	"tftp $fdtaddr $fdtfile;"			\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_NFSBOOTCOMMAND			\
+	"setenv bootargs root=/dev/nfs rw "	\
+	"nfsroot=$serverip:$rootpath "		\
+	"ip=$ipaddr:$serverip:$gatewayip:$netmask:$hostname:$netdev:off " \
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $loadaddr $bootfile;"		\
+	"tftp $fdtaddr $fdtfile;"		\
+	"bootm $loadaddr - $fdtaddr"
+
+#define CONFIG_RAMBOOTCOMMAND				\
+	"setenv bootargs root=/dev/ram rw "		\
+	"console=$consoledev,$baudrate $othbootargs;"	\
+	"tftp $ramdiskaddr $ramdiskfile;"		\
+	"tftp $loadaddr $bootfile;"			\
+	"tftp $fdtaddr $fdtfile;"			\
+	"bootm $loadaddr $ramdiskaddr $fdtaddr"
+
+#define CONFIG_BOOTCOMMAND		CONFIG_LINUX
+
+#ifdef CONFIG_SECURE_BOOT
+#include <asm/fsl_secure_boot.h>
+#define CONFIG_CMD_BLOB
+#undef CONFIG_CMD_USB
+#endif
+
+#endif	/* __CONFIG_TQMT2081_H */
-- 
1.9.1

